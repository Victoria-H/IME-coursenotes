<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>2.&nbsp;Coder les entiers relatifs</title><link rel="stylesheet" type="text/css" href="html.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="&Eacute;l&eacute;ments d'informatique"><link rel="up" href="codage.html" title="Chapitre&nbsp;2.&nbsp;Le codage de l'information"><link rel="prev" href="codage.html" title="Chapitre&nbsp;2.&nbsp;Le codage de l'information"><link rel="next" href="code-textes.html" title="3.&nbsp;Le codage des textes - premi&egrave;re approche"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">2.&nbsp;Coder les entiers relatifs</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="codage.html">Pr&eacute;c&eacute;dent</a>&nbsp;</td><th width="60%" align="center">Chapitre&nbsp;2.&nbsp;Le codage de l'information</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="code-textes.html">Suivant</a></td></tr></table><hr></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="code-negatifs"></a>2.&nbsp;Coder les entiers relatifs</h2></div></div></div><p>Nous avons vu que le codage des entiers naturels par une s&eacute;rie de bits se fait simplement en prenant l'&eacute;criture binaire... quid des entiers n&eacute;gatifs&nbsp;? La plus &eacute;l&eacute;mentaire, jamais utilis&eacute;e en pratique, consiste &agrave; utiliser l'un des bits (le premier) pour repr&eacute;senter le signe. Si l'on prend l'exemple d'un octet, on a alors un bit de signe et sept bits pour coder la valeur absolue (un nombre ind&eacute;pendamment de son signe). Dans ce cas, un m&ecirc;me octet peut repr&eacute;senter un nombre entre 0 et 255 ou un nombre entre -127 et +127 (exemple ci-dessous). Ce codage pr&eacute;sente deux d&eacute;fauts&nbsp;: l'addition est complexe (il faut traiter quatre cas) et le z&eacute;ro a deux repr&eacute;sentations (-0 et +0).</p><p>Exemples&nbsp;:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>+82 cod&eacute; sur un octet&nbsp;: &laquo;&nbsp;0&nbsp;1010010&nbsp;&raquo;</p></li><li class="listitem"><p>-82 cod&eacute; sur un octet avec la m&eacute;thode du bit de signe&nbsp;: &laquo;&nbsp;1&nbsp;1010010&nbsp;&raquo;</p></li><li class="listitem"><p>Les deux repr&eacute;sentations de 0 sur 1 octet avec la m&eacute;thode du bit de signe&nbsp;: &laquo;&nbsp;0&nbsp;0000000&nbsp;&raquo; et &laquo;&nbsp;1&nbsp;0000000&nbsp;&raquo;</p></li></ul></div><p>Pour ces raisons la m&eacute;thode du bit de signe seul n'est (presque) plus utilis&eacute;e. Une m&eacute;thode un peu plus efficiente consiste, pour coder -n, &agrave; prendre le compl&eacute;ment &agrave; un du codage de n, c'est &agrave; dire de remplacer chaque 0 par un 1 et inversement. Si l'on prend toujours l'exemple du codage sur un octet, on aura toujours un nombre entre -127 et +127 et toujours deux repr&eacute;sentations du z&eacute;ro, mais l'addition est maintenant plus facile &agrave; calculer. On peut d&eacute;montrer, en effet, que si l'on ajoute un nombre a et le compl&eacute;ment &agrave; un d'un nombre b, on trouve a-b-1 (aux probl&egrave;mes de d&eacute;passement pr&egrave;s). Pour cette raison, la m&eacute;thode (quasi) universellement choisie aujourd'hui pour repr&eacute;senter les entiers relatifs (positifs et n&eacute;gatifs) est celle du compl&eacute;ment &agrave; deux&nbsp;: on repr&eacute;sente un nombre n&eacute;gatif en prenant son compl&eacute;ment &agrave; un, puis en ajoutant un &agrave; l'&eacute;criture binaire obtenue. Dans le cas d'un codage sur un octet, on peut ainsi repr&eacute;senter les nombre entiers de -128 &agrave; +127.</p><p>Exemples&nbsp;:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>+82 cod&eacute; sur un octet&nbsp;: &laquo;&nbsp;<span class="emphasis"><em>0</em></span>1010010&nbsp;&raquo;</p></li><li class="listitem"><p>compl&eacute;ment &agrave; un de +82 sur 1 octet&nbsp;: &laquo;&nbsp;<span class="emphasis"><em>1</em></span>0101101&nbsp;&raquo; (m&ecirc;me chose que 255-82)</p></li><li class="listitem"><p>-82 cod&eacute; sur 1o = compl&eacute;ment &agrave; deux de +82&nbsp;: &laquo;&nbsp;<span class="emphasis"><em>1</em></span>0101110&nbsp;&raquo; (m&ecirc;me chose que 256-82)</p></li><li class="listitem"><p>-82 cod&eacute; sur deux octets&nbsp;: &laquo;&nbsp;<span class="emphasis"><em>1</em></span>1111111&nbsp;10101110&nbsp;&raquo;</p></li></ul></div><p>Si l'on travaille sur un octet, la repr&eacute;sentation binaire de -82 (en tant qu'entier positif ou n&eacute;gatif) est donc la m&ecirc;me que celle de 256-82 (en tant qu'entier positif), c'est &agrave; dire 174. Cela veut dire que &laquo;&nbsp;10101110&nbsp;&raquo; peut coder aussi bien le nombre -82 que le nombre 174. Il peut aussi coder de nombreuses autres choses, par exemple les caract&egrave;res &laquo;&nbsp;&reg;&nbsp;&raquo; (codage latin-1 des caract&egrave;res) ou &laquo;&nbsp;&#381;&nbsp;&raquo; (codage latin-2 des caract&egrave;res).</p><p>Les nombres &agrave; virgule et les grands entiers demandent, eux, des codages plus complexes.</p></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="codage.html">Pr&eacute;c&eacute;dent</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="codage.html">Niveau sup&eacute;rieur</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="code-textes.html">Suivant</a></td></tr><tr><td width="40%" align="left" valign="top">Chapitre&nbsp;2.&nbsp;Le codage de l'information&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Sommaire</a></td><td width="40%" align="right" valign="top">&nbsp;3.&nbsp;Le codage des textes - premi&egrave;re approche</td></tr></table></div></body></html>